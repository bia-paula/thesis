img_seqs = Input(shape=(time_steps, image_height, image_width, channels))
    task = Input(shape=(task_vector_size,))

    # ftask = Dense(1000, activation = 'relu')(task)
    offsets = Dense(channels, activation='tanh')(task)
    offsets = Dropout(.4)(offsets)
    # offsets = Reshape(target_shape = (channels,1,1))(offsets)
    combinedInput = Multiply()([img_seqs, offsets])
    # combinedInput = BatchNormalization()(combinedInput) #new

    if fix_first:
        # Fixation First
        y_fix, state_h, state_c = ConvLSTM2D(filters=5, strides=2, kernel_size=4, return_sequences=True,
                                             return_state=True,
                                             activation='relu')(combinedInput)

        state_aux = TimeDistributed(Flatten())(y_fix)
        y_det = Concatenate()([TimeDistributed(Flatten())(combinedInput), state_aux])

    else:
        # Detection First
        y_det, state_h, state_c = ConvLSTM2D(filters=5, strides=2, kernel_size=4, return_sequences=True, return_state=True,
                                             activation='relu')(combinedInput)
        y_fix = ConvLSTM2D(filters=5, strides=2, kernel_size=4, return_sequences=True, activation='relu')\
            (combinedInput, initial_state=[state_h, state_c])


    #y_det = BatchNormalization()(y_det)
    y_det = Dropout(0.5)(y_det)

    #z_det = TimeDistributed(Flatten())(y_det)
    out_det = Dense(64, activation='relu')(y_det)
    out_det = Dropout(0.5)(out_det)
    out_det = Dense(32, activation='relu')(out_det)
    out_det = Dropout(0.5)(out_det)
    out_det = Dense(1, activation='sigmoid', name='output_det')(out_det)

    # y = Dropout(.2)(y) #new
    y_fix = BatchNormalization()(y_fix)
    z_fix = TimeDistributed(Flatten())(y_fix)
    out_fix = Dense(output_size, activation='softmax', name='output_fix')(z_fix)

    model_rnn = Model([img_seqs, task], outputs=[out_fix, out_det])

    losses = {'output_fix': 'categorical_crossentropy',
              'output_det': create_weighted_binary_crossentropy(zero_weight=0.3, one_weight=0.7)}
    loss_weights = {'output_fix': w_fix, 'output_det': 1.0 - w_fix}

    metrics = {'output_fix': 'categorical_accuracy',
              'output_det': [tf.keras.metrics.BinaryAccuracy(), tf.keras.metrics.Recall(), tf.keras.metrics.Precision()]}
    model_rnn.compile(loss=losses, loss_weights=loss_weights, optimizer=Adam(learning_rate=1e-3),
                      metrics=metrics)  # rmsprop
    model_rnn.summary()

    return model_rnn